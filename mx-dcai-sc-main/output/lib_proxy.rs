// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct DcaiProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for DcaiProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = DcaiProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        DcaiProxyMethods { wrapped_tx: tx }
    }
}

pub struct DcaiProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> DcaiProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init(
        self,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> DcaiProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> DcaiProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn add_admins<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        addresses: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAdmins")
            .argument(&addresses)
            .original_result()
    }

    pub fn remove_admins<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        addresses: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAdmins")
            .argument(&addresses)
            .original_result()
    }

    pub fn is_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isAdmin")
            .argument(&address)
            .original_result()
    }

    pub fn admins(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmins")
            .original_result()
    }

    pub fn pause(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pause")
            .original_result()
    }

    pub fn unpause(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unpause")
            .original_result()
    }

    pub fn is_paused(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isPaused")
            .original_result()
    }

    pub fn get_usdc_identifier(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUsdcIdentifier")
            .original_result()
    }

    pub fn get_wegld_identifier(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWegldIdentifier")
            .original_result()
    }

    pub fn get_xexchange_router_sc_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getXexchangeRouterScAddress")
            .original_result()
    }

    pub fn get_wrapper_sc_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWrapperScAddress")
            .original_result()
    }

    pub fn set_bot_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBotAddress")
            .argument(&address)
            .original_result()
    }

    /// Endpoint executed by the bot to perform buy operations for multiple DCA strategies. 
    ///  
    /// Parameters: 
    /// - `nonces`: A list of nonces representing the DCA strategies to execute. 
    ///  
    /// The bot checks each strategy to see if it is eligible for execution based on the USDC balance, 
    /// the last executed timestamp, and the defined frequency. If eligible, it aggregates the total amount to swap, 
    /// performs the swap, and updates each strategy's attributes accordingly. 
    ///  
    /// It will skip strategies that do not meet the criteria and will return any 
    /// dust amount to the caller. It will fail only if no strategies at all are eligible for execution. 
    pub fn buy<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, u64>>,
    >(
        self,
        nonces: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("buy")
            .argument(&nonces)
            .original_result()
    }

    /// Endpoint executed by the bot to perform take profit operations for multiple DCA strategies. 
    ///  
    /// Parameters: 
    /// - `nonces`: A list of nonces representing the DCA strategies to evaluate for take profit. 
    ///  
    /// The bot checks each strategy to see if the take profit condition is met based on the 
    /// DCA token balance and the defined take profit percentage. If the condition is met, 
    /// it aggregates the total amount to swap, performs the swap, deducts any applicable profit 
    /// fees, and updates each strategy's attributes accordingly. 
    ///  
    /// It will skip strategies that do not meet the take profit condition and will return any 
    /// dust amount to the caller. It will fail only if no strategies at all are eligible for take profit. 
    pub fn take_profit<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, u64>>,
    >(
        self,
        nonces: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("takeProfit")
            .argument(&nonces)
            .original_result()
    }

    /// Returns true if the given address can execute bot operations. 
    ///  
    /// This includes the bot address and any admin addresses (as a fallback mechanism). 
    pub fn is_bot<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isBot")
            .argument(&address)
            .original_result()
    }

    pub fn bot_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBotAddress")
            .original_result()
    }

    pub fn setup<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<u64>,
        Arg5: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<ManagedBuffer<Env::Api>, u64>>>,
    >(
        self,
        dca_token: Arg0,
        strategy_token_ticker: Arg1,
        strategy_token_display_name: Arg2,
        min_amount_per_swap: Arg3,
        profit_fee_percentage: Arg4,
        allowed_frequencies: Arg5,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("setup")
            .argument(&dca_token)
            .argument(&strategy_token_ticker)
            .argument(&strategy_token_display_name)
            .argument(&min_amount_per_swap)
            .argument(&profit_fee_percentage)
            .argument(&allowed_frequencies)
            .original_result()
    }

    pub fn set_dca_token<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        dca_token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setToken")
            .argument(&dca_token)
            .original_result()
    }

    pub fn set_min_amount_per_swap<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        min_amount_per_swap: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMinAmountPerSwap")
            .argument(&min_amount_per_swap)
            .original_result()
    }

    pub fn add_allowed_frequencies<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<ManagedBuffer<Env::Api>, u64>>>,
    >(
        self,
        frequencies: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAllowedFrequencies")
            .argument(&frequencies)
            .original_result()
    }

    pub fn remove_allowed_frequencies<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedBuffer<Env::Api>>>,
    >(
        self,
        frequencies: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAllowedFrequencies")
            .argument(&frequencies)
            .original_result()
    }

    pub fn set_profit_fee_percentage<
        Arg0: ProxyArg<u64>,
    >(
        self,
        profit_fee_percentage: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setProfitFeePercentage")
            .argument(&profit_fee_percentage)
            .original_result()
    }

    pub fn set_custom_slippage_percentage<
        Arg0: ProxyArg<u64>,
    >(
        self,
        custom_slippage_percentage: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCustomSlippagePercentage")
            .argument(&custom_slippage_percentage)
            .original_result()
    }

    /// View to get the DCA setup parameters. 
    ///  
    /// Returns a `DcaSetup` multi-value containing: 
    /// 1. The DCA token identifier. 
    /// 1. The minimum amount per swap. 
    /// 1. The strategy token identifier. 
    /// 1. The profit fee percentage. 
    /// 1. The final slippage percentage to be used in swaps (either custom or default). 
    /// 1. The allowed frequencies as a multi-value encoded of `DcaFrequencyInMillis` (frequency string and duration in millis). 
    pub fn get_setup(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue8<EgldOrEsdtTokenIdentifier<Env::Api>, BigUint<Env::Api>, EsdtTokenIdentifier<Env::Api>, u64, u64, bool, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>, MultiValueEncoded<Env::Api, MultiValue2<ManagedBuffer<Env::Api>, u64>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSetup")
            .original_result()
    }

    /// Endpoint to create a new DCA strategy. 
    ///  
    /// ### Arguments 
    /// * `amount_per_swap` - The amount of USDC to be swapped in each DCA operation. 
    /// * `frequency` - The frequency at which DCA operations are executed (e.g., daily, weekly). 
    /// * `take_profit_percentage` - The percentage at which to take profit from DCA operations. 
    pub fn create_strategy<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        amount_per_swap: Arg0,
        frequency: Arg1,
        take_profit_percentage: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("createStrategy")
            .argument(&amount_per_swap)
            .argument(&frequency)
            .argument(&take_profit_percentage)
            .original_result()
    }

    /// Endpoint to modify an existing DCA strategy. 
    /// The endpoint is payable and requires the transfer of the strategy token NFT to identify the strategy. 
    ///  
    /// ### Arguments 
    /// * `amount_per_swap` - The new amount of USDC to be swapped in each DCA operation. 
    /// * `frequency` - The new frequency at which DCA operations are executed (e.g., daily, weekly). 
    /// * `take_profit_percentage` - The new percentage at which to take profit from DCA operations. 
    pub fn modify_strategy<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        amount_per_swap: Arg0,
        frequency: Arg1,
        take_profit_percentage: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("modifyStrategy")
            .argument(&amount_per_swap)
            .argument(&frequency)
            .argument(&take_profit_percentage)
            .original_result()
    }

    /// Endpoint to delete a DCA strategy. 
    /// The endpoint is payable and requires the transfer of the strategy token NFT to identify the strategy. 
    pub fn delete_strategy(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("deleteStrategy")
            .original_result()
    }

    /// Endpoint to deposit USDC into a strategy. 
    /// The endpoint is payable and requires the transfer of the strategy token NFT to identify the strategy. 
    pub fn deposit(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("deposit")
            .original_result()
    }

    /// Endpoint to withdraw USDC or DCA tokens from a strategy. 
    /// The endpoint is payable and requires the transfer of the strategy token NFT to identify the strategy. 
    ///  
    /// ### Arguments 
    /// * `amount` - The amount to withdraw. 
    /// * `token_withdrawn` - An enum indicating whether to withdraw USDC or DCA tokens (1 for USDC, 2 for DCA token). 
    pub fn withdraw<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<structs::TokenWithdrawn>,
    >(
        self,
        amount: Arg0,
        token_withdrawn: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("withdraw")
            .argument(&amount)
            .argument(&token_withdrawn)
            .original_result()
    }

    /// View to get the strategy token attributes for a given nonce 
    ///  
    /// ### Arguments 
    /// * `nonce` - The nonce of the strategy token NFT 
    ///  
    /// ### Returns 
    /// A `StrategyTokenAttributesAsType` containing the attributes of the strategy token: 
    /// - `nonce`: The nonce of the strategy token NFT. 
    /// - `amount_per_swap`: The amount of USDC to be swapped in each DCA operation. 
    /// - `dca_frequency`: The frequency at which DCA operations are executed (e.g., daily, weekly). 
    /// - `frequency_in_millis`: The frequency in milliseconds for precise timing. 
    /// - `take_profit_percentage`: The percentage at which to take profit from DCA operations. 
    /// - `usdc_balance`: The current USDC balance allocated for DCA operations. 
    /// - `dca_token_balance`: The current balance of the token being acquired through DCA. 
    /// - `last_executed_ts_millis`: The timestamp in milliseconds of the last executed DCA operation. 
    /// - `take_profit_condition_met`: A boolean indicating whether the take profit condition is currently met (if applicable). 
    /// - `buys`: A list of executed buy operations, each represented by a `Swap` struct (including usdc amount, dca token amount, and timestamp). 
    /// - `sells`: A list of executed sell operations, each represented by a `Swap` struct (including usdc amount, dca token amount, and timestamp). 
    pub fn get_strategy_token_attributes_view<
        Arg0: ProxyArg<u64>,
    >(
        self,
        nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue11<u64, BigUint<Env::Api>, ManagedBuffer<Env::Api>, u64, u64, BigUint<Env::Api>, BigUint<Env::Api>, u64, bool, ManagedVec<Env::Api, structs::Swap<Env::Api>>, ManagedVec<Env::Api, structs::Swap<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStrategyTokenAttributes")
            .argument(&nonce)
            .original_result()
    }

    /// View to get all strategies held by the smart contract. 
    ///  
    /// It iterates through all minted strategy token NFTs and collects the attributes of those 
    /// that have a balance greater than zero. 
    ///  
    /// ### Returns 
    /// A `MultiValueEncoded` containing `StrategyTokenAttributesAsType` for each strategy. 
    ///  
    /// Each `StrategyTokenAttributesAsType` includes: 
    /// - `nonce`: The nonce of the strategy token NFT. 
    /// - `amount_per_swap`: The amount of USDC to be swapped in each DCA operation. 
    /// - `dca_frequency`: The frequency at which DCA operations are executed. 
    /// - `frequency_in_millis`: The frequency in milliseconds for precise timing. 
    /// - `take_profit_percentage`: The percentage at which to take profit from DCA operations. 
    /// - `usdc_balance`: The current USDC balance allocated for DCA operations. 
    /// - `dca_token_balance`: The current balance of the token being acquired through DCA. 
    /// - `last_executed_ts_millis`: The timestamp in milliseconds of the last executed buy or take profit operation. 
    /// - `take_profit_condition_met`: A boolean indicating whether the take profit condition is currently met (if applicable). 
    /// - `buys`: A list of executed buy operations, each represented by a `Swap` struct. 
    /// - `sells`: A list of executed sell operations, each represented by a `Swap` struct. 
    pub fn get_all_strategies(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue11<u64, BigUint<Env::Api>, ManagedBuffer<Env::Api>, u64, u64, BigUint<Env::Api>, BigUint<Env::Api>, u64, bool, ManagedVec<Env::Api, structs::Swap<Env::Api>>, ManagedVec<Env::Api, structs::Swap<Env::Api>>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllStrategies")
            .original_result()
    }

    /// View to get all strategy nonces held by the smart contract. 
    ///  
    /// It iterates through all minted strategy token NFTs and collects the nonces of those 
    /// that have a balance greater than zero. 
    ///  
    /// ### Returns 
    /// A `MultiValueEncoded` containing the nonces of each strategy. 
    pub fn get_all_strategies_only_nonces(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllStrategiesOnlyNonces")
            .original_result()
    }
}
